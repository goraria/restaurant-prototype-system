import { PrismaClient, tables, reservations, table_orders } from '@prisma/client';
import { 
  CreateTable, 
  UpdateTable, 
  TableQuery,
  CreateReservation, 
  UpdateReservation, 
  ReservationQuery,
  CreateTableOrder, 
  UpdateTableOrder, 
  TableOrderQuery,
  TableAvailability,
  UpdateTableStatus,
  GenerateQRCode,
  ConfirmReservation,
  TableCheckIn,
  TableStatsQuery,
  ReservationStatsQuery
} from '@/schemas/tableSchemas';
import { validate } from 'uuid';

const prisma = new PrismaClient();

// ================================
// üîß HELPER FUNCTIONS
// ================================

// const validateUUID = (id: string): boolean => {
//   const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
//   return uuidRegex.test(id);
// };

const generateSessionCode = (): string => {
  return Math.random().toString(36).substring(2, 10).toUpperCase();
};

// ================================
// ü™ë TABLE SERVICES
// ================================

export async function getAllTable() {
  try {
    const tables = await prisma.tables.findMany({
      include: {
        restaurants: {
          select: {
            id: true,
            name: true,
            code: true,
          }
        },
        _count: {
          select: {
            reservations: true,
            table_orders: true,
          }
        }
      },
    })

    if (!tables) return

    return tables
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y danh s√°ch b√†n: ${error}`);
  }
}

// T·∫°o b√†n m·ªõi
export const createTable = async (data: CreateTable) => {
  try {
    // Ki·ªÉm tra nh√† h√†ng t·ªìn t·∫°i
    const restaurant = await prisma.restaurants.findUnique({
      where: { id: data.restaurant_id }
    });

    if (!restaurant) {
      throw new Error('Nh√† h√†ng kh√¥ng t·ªìn t·∫°i');
    }

    // Ki·ªÉm tra s·ªë b√†n ƒë√£ t·ªìn t·∫°i trong nh√† h√†ng
    const existingTable = await prisma.tables.findUnique({
      where: {
        restaurant_id_table_number: {
          restaurant_id: data.restaurant_id,
          table_number: data.table_number
        }
      }
    });

    if (existingTable) {
      throw new Error(`S·ªë b√†n ${data.table_number} ƒë√£ t·ªìn t·∫°i trong nh√† h√†ng`);
    }

    const table = await prisma.tables.create({
      data: {
        ...data,
        status: data.status || 'available',
        created_at: new Date(),
        updated_at: new Date(),
      },
      include: {
        restaurants: {
          select: {
            id: true,
            name: true,
            code: true,
          }
        },
        _count: {
          select: {
            reservations: true,
            table_orders: true,
          }
        }
      }
    });

    return table;
  } catch (error) {
    throw new Error(`L·ªói khi t·∫°o b√†n: ${error}`);
  }
};

// L·∫•y b√†n theo ID
export const getTableById = async (id: string) => {
  try {
    if (!validate(id)) {
      throw new Error('ID b√†n kh√¥ng h·ª£p l·ªá');
    }

    const table = await prisma.tables.findUnique({
      where: { id },
      include: {
        restaurants: {
          select: {
            id: true,
            name: true,
            code: true,
          }
        },
        reservations: {
          where: {
            status: { in: ['pending', 'confirmed', 'seated'] },
            reservation_date: {
              gte: new Date()
            }
          },
          orderBy: { reservation_date: 'asc' },
          take: 5,
          include: {
            customers: {
              select: {
                id: true,
                first_name: true,
                last_name: true,
                phone_number: true,
              }
            }
          }
        },
        table_orders: {
          where: { status: 'active' },
          include: {
            orders: {
              select: {
                id: true,
                order_code: true,
                total_amount: true,
                status: true,
              }
            },
            staff: {
              select: {
                id: true,
                first_name: true,
                last_name: true,
              }
            }
          }
        }
      }
    });

    if (!table) {
      throw new Error('Kh√¥ng t√¨m th·∫•y b√†n');
    }

    return table;
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y th√¥ng tin b√†n: ${error}`);
  }
};

// L·∫•y danh s√°ch b√†n v·ªõi filter
export const getTables = async (filters: TableQuery) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort_by = 'table_number', 
      sort_order = 'asc', 
      ...whereFilters 
    } = filters;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (whereFilters.restaurant_id) {
      where.restaurant_id = whereFilters.restaurant_id;
    }

    if (whereFilters.status) {
      where.status = whereFilters.status;
    }

    if (whereFilters.location) {
      where.location = {
        contains: whereFilters.location,
        mode: 'insensitive'
      };
    }

    if (whereFilters.min_capacity || whereFilters.max_capacity) {
      where.capacity = {};
      if (whereFilters.min_capacity) where.capacity.gte = whereFilters.min_capacity;
      if (whereFilters.max_capacity) where.capacity.lte = whereFilters.max_capacity;
    }

    const [tables, total] = await Promise.all([
      prisma.tables.findMany({
        where,
        include: {
          restaurants: {
            select: {
              id: true,
              name: true,
              code: true,
            }
          },
          _count: {
            select: {
              reservations: true,
              table_orders: true,
            }
          }
        },
        orderBy: { [sort_by]: sort_order },
        skip,
        take: limit,
      }),
      prisma.tables.count({ where })
    ]);

    return {
      data: tables,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y danh s√°ch b√†n: ${error}`);
  }
};

// L·∫•y b√†n theo nh√† h√†ng
export const getTablesByRestaurantId = async (restaurantId: string) => {
  try {
    if (!validate(restaurantId)) {
      throw new Error('ID nh√† h√†ng kh√¥ng h·ª£p l·ªá');
    }

    const tables = await prisma.tables.findMany({
      where: { restaurant_id: restaurantId },
      include: {
        _count: {
          select: {
            reservations: {
              where: {
                status: { in: ['pending', 'confirmed', 'seated'] },
                reservation_date: {
                  gte: new Date()
                }
              }
            },
            table_orders: {
              where: { status: 'active' }
            }
          }
        }
      },
      orderBy: { table_number: 'asc' },
    });

    return tables;
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y b√†n c·ªßa nh√† h√†ng: ${error}`);
  }
};

// C·∫≠p nh·∫≠t b√†n
export const updateTable = async (id: string, data: UpdateTable) => {
  try {
    if (!validate(id)) {
      throw new Error('ID b√†n kh√¥ng h·ª£p l·ªá');
    }

    const existingTable = await prisma.tables.findUnique({
      where: { id }
    });

    if (!existingTable) {
      throw new Error('Kh√¥ng t√¨m th·∫•y b√†n');
    }

    // Ki·ªÉm tra s·ªë b√†n n·∫øu c√≥ thay ƒë·ªïi
    if (data.table_number && data.table_number !== existingTable.table_number) {
      const duplicateTable = await prisma.tables.findUnique({
        where: {
          restaurant_id_table_number: {
            restaurant_id: existingTable.restaurant_id,
            table_number: data.table_number
          }
        }
      });

      if (duplicateTable) {
        throw new Error(`S·ªë b√†n ${data.table_number} ƒë√£ t·ªìn t·∫°i trong nh√† h√†ng`);
      }
    }

    const updatedTable = await prisma.tables.update({
      where: { id },
      data: {
        ...data,
        updated_at: new Date(),
      },
      include: {
        restaurants: {
          select: {
            id: true,
            name: true,
            code: true,
          }
        }
      }
    });

    return updatedTable;
  } catch (error) {
    throw new Error(`L·ªói khi c·∫≠p nh·∫≠t b√†n: ${error}`);
  }
};

// X√≥a b√†n
export const deleteTable = async (id: string) => {
  try {
    if (!validate(id)) {
      throw new Error('ID b√†n kh√¥ng h·ª£p l·ªá');
    }

    const existingTable = await prisma.tables.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            reservations: true,
            table_orders: true,
          }
        }
      }
    });

    if (!existingTable) {
      throw new Error('Kh√¥ng t√¨m th·∫•y b√†n');
    }

    if (existingTable._count.reservations > 0 || existingTable._count.table_orders > 0) {
      throw new Error('Kh√¥ng th·ªÉ x√≥a b√†n c√≥ l·ªãch ƒë·∫∑t ho·∫∑c ƒë∆°n h√†ng');
    }

    await prisma.tables.delete({
      where: { id }
    });

    return { message: 'X√≥a b√†n th√†nh c√¥ng' };
  } catch (error) {
    throw new Error(`L·ªói khi x√≥a b√†n: ${error}`);
  }
};

// Ki·ªÉm tra b√†n tr·ªëng
export const checkTableAvailability = async (data: TableAvailability) => {
  try {
    const { restaurant_id, party_size, reservation_date, duration_hours = 2 } = data;

    if (!validate(restaurant_id)) {
      throw new Error('ID nh√† h√†ng kh√¥ng h·ª£p l·ªá');
    }

    const startTime = new Date(reservation_date);
    const endTime = new Date(startTime.getTime() + duration_hours * 60 * 60 * 1000);

    // T√¨m b√†n c√≥ s·ª©c ch·ª©a ph√π h·ª£p
    const availableTables = await prisma.tables.findMany({
      where: {
        restaurant_id,
        capacity: { gte: party_size },
        status: { in: ['available'] },
        // Ki·ªÉm tra kh√¥ng c√≥ ƒë·∫∑t b√†n tr√πng th·ªùi gian
        reservations: {
          none: {
            status: { in: ['confirmed', 'seated'] },
            AND: [
              { reservation_date: { lt: endTime } },
              {
                reservation_date: {
                  gte: new Date(startTime.getTime() - 2 * 60 * 60 * 1000) // Buffer 2 hours
                }
              }
            ]
          }
        }
      },
      orderBy: [
        { capacity: 'asc' }, // ∆Øu ti√™n b√†n v·ª´a ƒë·ªß
        { table_number: 'asc' }
      ]
    });

    return availableTables;
  } catch (error) {
    throw new Error(`L·ªói khi ki·ªÉm tra b√†n tr·ªëng: ${error}`);
  }
};

// C·∫≠p nh·∫≠t tr·∫°ng th√°i nhi·ªÅu b√†n
export const updateTableStatus = async (data: UpdateTableStatus) => {
  try {
    const { table_ids, status } = data;

    // Ki·ªÉm tra t·∫•t c·∫£ IDs h·ª£p l·ªá
    for (const id of table_ids) {
      if (!validate(id)) {
        throw new Error(`ID b√†n kh√¥ng h·ª£p l·ªá: ${id}`);
      }
    }

    const updatedTables = await prisma.tables.updateMany({
      where: {
        id: { in: table_ids }
      },
      data: {
        status,
        updated_at: new Date(),
      }
    });

    return {
      message: `ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ${updatedTables.count} b√†n th√†nh ${status}`,
      count: updatedTables.count
    };
  } catch (error) {
    throw new Error(`L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n: ${error}`);
  }
};

// ================================
// üìÖ RESERVATION SERVICES
// ================================

// T·∫°o ƒë·∫∑t b√†n m·ªõi
export const createReservation = async (data: CreateReservation) => {
  try {
    // Ki·ªÉm tra b√†n t·ªìn t·∫°i
    const table = await prisma.tables.findUnique({
      where: { id: data.table_id }
    });

    if (!table) {
      throw new Error('B√†n kh√¥ng t·ªìn t·∫°i');
    }

    // Ki·ªÉm tra s·ª©c ch·ª©a
    if (data.party_size > table.capacity) {
      throw new Error(`B√†n ${table.table_number} ch·ªâ c√≥ s·ª©c ch·ª©a ${table.capacity} ng∆∞·ªùi`);
    }

    // Ki·ªÉm tra kh√°ch h√†ng n·∫øu c√≥
    if (data.customer_id) {
      const customer = await prisma.users.findUnique({
        where: { id: data.customer_id }
      });

      if (!customer) {
        throw new Error('Kh√°ch h√†ng kh√¥ng t·ªìn t·∫°i');
      }
    }

    // Ki·ªÉm tra th·ªùi gian tr√πng l·∫∑p
    const conflictingReservation = await prisma.reservations.findFirst({
      where: {
        table_id: data.table_id,
        status: { in: ['confirmed', 'seated'] },
        reservation_date: {
          gte: new Date(data.reservation_date.getTime() - 2 * 60 * 60 * 1000),
          lte: new Date(data.reservation_date.getTime() + 2 * 60 * 60 * 1000)
        }
      }
    });

    if (conflictingReservation) {
      throw new Error('B√†n ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t trong kho·∫£ng th·ªùi gian n√†y');
    }

    const reservation = await prisma.reservations.create({
      data: {
        ...data,
        duration_hours: data.duration_hours || 2,
        status: 'pending',
        created_at: new Date(),
        updated_at: new Date(),
      },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
            restaurants: {
              select: {
                id: true,
                name: true,
                address: true,
                phone_number: true,
              }
            }
          }
        },
        customers: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
            email: true,
            phone_number: true,
          }
        }
      }
    });

    return reservation;
  } catch (error) {
    throw new Error(`L·ªói khi t·∫°o ƒë·∫∑t b√†n: ${error}`);
  }
};

// L·∫•y ƒë·∫∑t b√†n theo ID
export const getReservationById = async (id: string) => {
  try {
    if (!validate(id)) {
      throw new Error('ID ƒë·∫∑t b√†n kh√¥ng h·ª£p l·ªá');
    }

    const reservation = await prisma.reservations.findUnique({
      where: { id },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
            restaurants: {
              select: {
                id: true,
                name: true,
                address: true,
                phone_number: true,
              }
            }
          }
        },
        customers: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
            email: true,
            phone_number: true,
          }
        }
      }
    });

    if (!reservation) {
      throw new Error('Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n');
    }

    return reservation;
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y th√¥ng tin ƒë·∫∑t b√†n: ${error}`);
  }
};

// L·∫•y danh s√°ch ƒë·∫∑t b√†n
export const getReservations = async (filters: ReservationQuery) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort_by = 'reservation_date', 
      sort_order = 'asc', 
      ...whereFilters 
    } = filters;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (whereFilters.table_id) {
      where.table_id = whereFilters.table_id;
    }

    if (whereFilters.customer_id) {
      where.customer_id = whereFilters.customer_id;
    }

    if (whereFilters.customer_phone) {
      where.customer_phone = {
        contains: whereFilters.customer_phone,
        mode: 'insensitive'
      };
    }

    if (whereFilters.status) {
      where.status = whereFilters.status;
    }

    if (whereFilters.date_from || whereFilters.date_to) {
      where.reservation_date = {};
      if (whereFilters.date_from) where.reservation_date.gte = whereFilters.date_from;
      if (whereFilters.date_to) where.reservation_date.lte = whereFilters.date_to;
    }

    if (whereFilters.party_size_min || whereFilters.party_size_max) {
      where.party_size = {};
      if (whereFilters.party_size_min) where.party_size.gte = whereFilters.party_size_min;
      if (whereFilters.party_size_max) where.party_size.lte = whereFilters.party_size_max;
    }

    const [reservations, total] = await Promise.all([
      prisma.reservations.findMany({
        where,
        include: {
          tables: {
            select: {
              id: true,
              table_number: true,
              capacity: true,
              location: true,
            }
          },
          customers: {
            select: {
              id: true,
              first_name: true,
              last_name: true,
            }
          }
        },
        orderBy: { [sort_by]: sort_order },
        skip,
        take: limit,
      }),
      prisma.reservations.count({ where })
    ]);

    return {
      data: reservations,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y danh s√°ch ƒë·∫∑t b√†n: ${error}`);
  }
};

// C·∫≠p nh·∫≠t ƒë·∫∑t b√†n
export const updateReservation = async (id: string, data: UpdateReservation) => {
  try {
    if (!validate(id)) {
      throw new Error('ID ƒë·∫∑t b√†n kh√¥ng h·ª£p l·ªá');
    }

    const existingReservation = await prisma.reservations.findUnique({
      where: { id },
      include: { tables: true }
    });

    if (!existingReservation) {
      throw new Error('Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n');
    }

    // Ki·ªÉm tra s·ª©c ch·ª©a n·∫øu thay ƒë·ªïi s·ªë ng∆∞·ªùi
    if (data.party_size && data.party_size > existingReservation.tables.capacity) {
      throw new Error(`B√†n ${existingReservation.tables.table_number} ch·ªâ c√≥ s·ª©c ch·ª©a ${existingReservation.tables.capacity} ng∆∞·ªùi`);
    }

    const updatedReservation = await prisma.reservations.update({
      where: { id },
      data: {
        ...data,
        updated_at: new Date(),
      },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
          }
        },
        customers: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
          }
        }
      }
    });

    return updatedReservation;
  } catch (error) {
    throw new Error(`L·ªói khi c·∫≠p nh·∫≠t ƒë·∫∑t b√†n: ${error}`);
  }
};

// X√°c nh·∫≠n ƒë·∫∑t b√†n
export const confirmReservation = async (data: ConfirmReservation) => {
  try {
    const { reservation_id, notes } = data;

    if (!validate(reservation_id)) {
      throw new Error('ID ƒë·∫∑t b√†n kh√¥ng h·ª£p l·ªá');
    }

    const reservation = await prisma.reservations.findUnique({
      where: { id: reservation_id }
    });

    if (!reservation) {
      throw new Error('Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n');
    }

    if (reservation.status !== 'pending') {
      throw new Error('Ch·ªâ c√≥ th·ªÉ x√°c nh·∫≠n ƒë·∫∑t b√†n ƒëang ch·ªù');
    }

    const updatedReservation = await prisma.reservations.update({
      where: { id: reservation_id },
      data: {
        status: 'confirmed',
        notes: notes || reservation.notes,
        updated_at: new Date(),
      },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
          }
        }
      }
    });

    return updatedReservation;
  } catch (error) {
    throw new Error(`L·ªói khi x√°c nh·∫≠n ƒë·∫∑t b√†n: ${error}`);
  }
};

// Check-in kh√°ch h√†ng
export const checkInTable = async (data: TableCheckIn) => {
  try {
    const { reservation_id, table_id, party_size, staff_id } = data;

    // Validate inputs
    if (reservation_id && !validate(reservation_id)) {
      throw new Error('ID ƒë·∫∑t b√†n kh√¥ng h·ª£p l·ªá');
    }
    if (!validate(table_id)) {
      throw new Error('ID b√†n kh√¥ng h·ª£p l·ªá');
    }
    if (!validate(staff_id)) {
      throw new Error('ID nh√¢n vi√™n kh√¥ng h·ª£p l·ªá');
    }

    // Ki·ªÉm tra b√†n
    const table = await prisma.tables.findUnique({
      where: { id: table_id }
    });

    if (!table) {
      throw new Error('B√†n kh√¥ng t·ªìn t·∫°i');
    }

    if (table.status !== 'available') {
      throw new Error('B√†n kh√¥ng c√≥ s·∫µn');
    }

    if (party_size > table.capacity) {
      throw new Error(`B√†n ${table.table_number} ch·ªâ c√≥ s·ª©c ch·ª©a ${table.capacity} ng∆∞·ªùi`);
    }

    // C·∫≠p nh·∫≠t reservation n·∫øu c√≥
    if (reservation_id) {
      await prisma.reservations.update({
        where: { id: reservation_id },
        data: {
          status: 'seated',
          updated_at: new Date(),
        }
      });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n
    await prisma.tables.update({
      where: { id: table_id },
      data: {
        status: 'occupied',
        updated_at: new Date(),
      }
    });

    // T·∫°o table order session
    const tableOrder = await prisma.table_orders.create({
      data: {
        table_id,
        session_code: generateSessionCode(),
        status: 'active',
        staff_id,
        opened_at: new Date(),
      },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
          }
        },
        staff: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
          }
        }
      }
    });

    return tableOrder;
  } catch (error) {
    throw new Error(`L·ªói khi check-in: ${error}`);
  }
};

// ================================
// üçΩÔ∏è TABLE ORDER SERVICES
// ================================

// T·∫°o table order
export const createTableOrder = async (data: CreateTableOrder) => {
  try {
    // Ki·ªÉm tra b√†n
    const table = await prisma.tables.findUnique({
      where: { id: data.table_id }
    });

    if (!table) {
      throw new Error('B√†n kh√¥ng t·ªìn t·∫°i');
    }

    // Ki·ªÉm tra staff n·∫øu c√≥
    if (data.staff_id) {
      const staff = await prisma.users.findUnique({
        where: { id: data.staff_id }
      });

      if (!staff) {
        throw new Error('Nh√¢n vi√™n kh√¥ng t·ªìn t·∫°i');
      }
    }

    const tableOrder = await prisma.table_orders.create({
      data: {
        table_id: data.table_id,
        session_code: data.session_code || generateSessionCode(),
        staff_id: data.staff_id,
        status: 'active',
        opened_at: new Date(),
      },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
          }
        },
        staff: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
          }
        }
      }
    });

    return tableOrder;
  } catch (error) {
    throw new Error(`L·ªói khi t·∫°o phi√™n b√†n: ${error}`);
  }
};

// L·∫•y table order theo ID
export const getTableOrderById = async (id: string) => {
  try {
    if (!validate(id)) {
      throw new Error('ID phi√™n b√†n kh√¥ng h·ª£p l·ªá');
    }

    const tableOrder = await prisma.table_orders.findUnique({
      where: { id },
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
            restaurants: {
              select: {
                id: true,
                name: true,
              }
            }
          }
        },
        orders: {
          select: {
            id: true,
            order_code: true,
            total_amount: true,
            status: true,
            payment_status: true,
          }
        },
        staff: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
          }
        }
      }
    });

    if (!tableOrder) {
      throw new Error('Kh√¥ng t√¨m th·∫•y phi√™n b√†n');
    }

    return tableOrder;
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y th√¥ng tin phi√™n b√†n: ${error}`);
  }
};

// L·∫•y danh s√°ch table orders
export const getTableOrders = async (filters: TableOrderQuery) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort_by = 'opened_at', 
      sort_order = 'desc', 
      ...whereFilters 
    } = filters;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (whereFilters.table_id) {
      where.table_id = whereFilters.table_id;
    }

    if (whereFilters.order_id) {
      where.order_id = whereFilters.order_id;
    }

    if (whereFilters.status) {
      where.status = whereFilters.status;
    }

    if (whereFilters.staff_id) {
      where.staff_id = whereFilters.staff_id;
    }

    if (whereFilters.session_code) {
      where.session_code = {
        contains: whereFilters.session_code,
        mode: 'insensitive'
      };
    }

    if (whereFilters.date_from || whereFilters.date_to) {
      where.opened_at = {};
      if (whereFilters.date_from) where.opened_at.gte = whereFilters.date_from;
      if (whereFilters.date_to) where.opened_at.lte = whereFilters.date_to;
    }

    const [tableOrders, total] = await Promise.all([
      prisma.table_orders.findMany({
        where,
        include: {
          tables: {
            select: {
              id: true,
              table_number: true,
              capacity: true,
              location: true,
            }
          },
          orders: {
            select: {
              id: true,
              order_code: true,
              total_amount: true,
              status: true,
            }
          },
          staff: {
            select: {
              id: true,
              first_name: true,
              last_name: true,
            }
          }
        },
        orderBy: { [sort_by]: sort_order },
        skip,
        take: limit,
      }),
      prisma.table_orders.count({ where })
    ]);

    return {
      data: tableOrders,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y danh s√°ch phi√™n b√†n: ${error}`);
  }
};

// C·∫≠p nh·∫≠t table order
export const updateTableOrder = async (id: string, data: UpdateTableOrder) => {
  try {
    if (!validate(id)) {
      throw new Error('ID phi√™n b√†n kh√¥ng h·ª£p l·ªá');
    }

    const existingTableOrder = await prisma.table_orders.findUnique({
      where: { id }
    });

    if (!existingTableOrder) {
      throw new Error('Kh√¥ng t√¨m th·∫•y phi√™n b√†n');
    }

    const updateData: any = { ...data };

    // T·ª± ƒë·ªông set th·ªùi gian ƒë√≥ng khi status = completed
    if (data.status === 'completed' && !existingTableOrder.closed_at) {
      updateData.closed_at = new Date();
    }

    const updatedTableOrder = await prisma.table_orders.update({
      where: { id },
      data: updateData,
      include: {
        tables: {
          select: {
            id: true,
            table_number: true,
            capacity: true,
            location: true,
          }
        },
        orders: {
          select: {
            id: true,
            order_code: true,
            total_amount: true,
            status: true,
          }
        }
      }
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n khi ƒë√≥ng phi√™n
    if (data.status === 'completed') {
      await prisma.tables.update({
        where: { id: existingTableOrder.table_id },
        data: { status: 'available' }
      });
    }

    return updatedTableOrder;
  } catch (error) {
    throw new Error(`L·ªói khi c·∫≠p nh·∫≠t phi√™n b√†n: ${error}`);
  }
};

// ================================
// üìä STATISTICS FUNCTIONS
// ================================

// Th·ªëng k√™ b√†n
export const getTableStats = async (data: TableStatsQuery) => {
  try {
    const { restaurant_id, date_from, date_to } = data;

    if (!validate(restaurant_id)) {
      throw new Error('ID nh√† h√†ng kh√¥ng h·ª£p l·ªá');
    }

    const dateFilter = date_from && date_to ? {
      gte: date_from,
      lte: date_to
    } : undefined;

    const [
      totalTables,
      availableTables,
      occupiedTables,
      maintenanceTables,
      totalReservations,
      confirmedReservations,
      avgOccupancyRate
    ] = await Promise.all([
      prisma.tables.count({
        where: { restaurant_id }
      }),
      prisma.tables.count({
        where: { 
          restaurant_id,
          status: 'available' 
        }
      }),
      prisma.tables.count({
        where: { 
          restaurant_id,
          status: 'occupied' 
        }
      }),
      prisma.tables.count({
        where: { 
          restaurant_id,
          status: { in: ['maintenance', 'out_of_order'] }
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'confirmed',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      // Calculate average occupancy rate
      prisma.table_orders.aggregate({
        where: { 
          tables: { restaurant_id },
          status: 'completed',
          ...(dateFilter && { opened_at: dateFilter })
        },
        _avg: {
          total_amount: true
        }
      })
    ]);

    return {
      total_tables: totalTables,
      available_tables: availableTables,
      occupied_tables: occupiedTables,
      maintenance_tables: maintenanceTables,
      total_reservations: totalReservations,
      confirmed_reservations: confirmedReservations,
      reservation_rate: totalReservations > 0 ? (confirmedReservations / totalReservations * 100) : 0,
      avg_order_value: avgOccupancyRate._avg.total_amount || 0,
    };
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y th·ªëng k√™ b√†n: ${error}`);
  }
};

// Th·ªëng k√™ ƒë·∫∑t b√†n
export const getReservationStats = async (data: ReservationStatsQuery) => {
  try {
    const { restaurant_id, date_from, date_to } = data;

    if (!validate(restaurant_id)) {
      throw new Error('ID nh√† h√†ng kh√¥ng h·ª£p l·ªá');
    }

    const dateFilter = date_from && date_to ? {
      gte: date_from,
      lte: date_to
    } : undefined;

    const [
      totalReservations,
      pendingReservations,
      confirmedReservations,
      seatedReservations,
      completedReservations,
      cancelledReservations,
      noShowReservations
    ] = await Promise.all([
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'pending',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'confirmed',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'seated',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'completed',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'cancelled',
          ...(dateFilter && { created_at: dateFilter })
        }
      }),
      prisma.reservations.count({
        where: { 
          tables: { restaurant_id },
          status: 'no_show',
          ...(dateFilter && { created_at: dateFilter })
        }
      })
    ]);

    return {
      total_reservations: totalReservations,
      pending_reservations: pendingReservations,
      confirmed_reservations: confirmedReservations,
      seated_reservations: seatedReservations,
      completed_reservations: completedReservations,
      cancelled_reservations: cancelledReservations,
      no_show_reservations: noShowReservations,
      success_rate: totalReservations > 0 ? (completedReservations / totalReservations * 100) : 0,
      cancellation_rate: totalReservations > 0 ? (cancelledReservations / totalReservations * 100) : 0,
      no_show_rate: totalReservations > 0 ? (noShowReservations / totalReservations * 100) : 0,
    };
  } catch (error) {
    throw new Error(`L·ªói khi l·∫•y th·ªëng k√™ ƒë·∫∑t b√†n: ${error}`);
  }
};
